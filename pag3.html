<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title> Metoda Backtracking </title>
</head>
<body>
    <b> <i>  Proiect realizat de către Condrea Mădălina, elevă în clasa a XII-a C </i></b>
    <header> 
        <table class="main"> <tr> 
      <th>  <a href="index.html"> Metoda Recursie </a> </th> &emsp;
      <th>   <a href="pag1.html"> Metoda Trierii </a> </th> &emsp;
      <th>  <a href="pag2.html"> Metoda Greedy </a> </th> &emsp;
      <th>  <a href="pag3.html"> Metoda Backtracking </a> </th>;
    </tr>  </table> </header>
    <br> <br> <br> 
    <hr class="new1">
    <h1 class="back"> <center>  Metoda Backtracking </center> </h1> 

     <div> <span class="backtracking"> <b> Backtracking-ul </b> este o metodă de parcurgere sistematică a spaţiului soluţiilor posibile al unei probleme.
         Este o metodă generală de programare, 
        şi poate fi adaptată pentru orice problemă pentru care dorim să obţinem toate soluţiile posibile, sau să selectăm o soluţie optimă,
         din mulţimea soluţiilor posibile.
        Backtracking este însă şi cea mai costisitoare metodă din punct de vedere al timpului de execuţie.
     </span> 
<span class="space2"> </span>
     <span class="back2"> 
        <b> Metoda backtracking </b> încearcă micşorarea timpului de 
calcul, realizând o căutare sistematică în spaţiul 
soluţiilor posibile.
Se foloseşte în cazul problemelor a căror soluţie este un 
vector x = (x1, x2, ..., xn), unde fiecare xn aparține unei mulţimi finite Ai, 
elementele mulțimilor Ai aflându-se într-o relaţie de ordine bine stabilită.
         <b> Problemele  </b> care se rezolvă prin metoda backtracking pot fi împărţite în mai multe grupuri
de probleme cu rezolvări asemănătoare, în funcţie de modificările pe care le vom face în algoritm. 
 </span>
    </div> 

    <h2 style="text-align:center;"> Backtracking = parcurgerea limitată (conform 
        condiţiilor de continuare) în adâncime a unui 
        arbore.</h2> 
    <ul class="lista"> Spaţiul soluţiilor este organizat ca un arbore: 
        <li> un vârf este viabil dacă sunt şanse să se 
            găsească o soluţie explorând subarborele cu 
            rădăcina în acel vârf;  </li>
            <li> sunt exploraţi numai subarborii cu rădăcini
                viabile. </li>
    </ul>

    <br> 

    <div> 
        <span class="exemplu1"> 
            <h2> <center>  Problema 1 </center> </h2>
    <p> 
        Fie n şi m două numere naturale nenule, m <= n. Să se genereze combinările de n
elemente luate câte m.
Indicaţii: diferenţa faţă de generarea aranjamentelor constă în faptul că se generează
elementele în ordine strict crescătoare.
    </p>
   
</span> 
<span class="space3"> </span>
<span class="exemplu2"> 
    <h2> <center>  Problema 2 </center> </h2>
 <p> 
    Să se genereze produsul cartezian al mulţimii {1,2,...,n} cu ea însăşi de m ori.
    Indicaţii: deosebirea faţă de generarea aranjamentelor constă în lipsa validării, deoarece în
    produsul cartezian elementele se pot repeta.    
 </p> </span> </div>

   <img src="../images/problema1.jpg" class="prob1">  
   <span class="space4"> </span>
   <img src="../images/problema2.jpg" class="prob2"> 
<br> <br> <br> 

<span class="exemplu3"> 
   <h1 style="text-align:center;"> Problema 3  </h1>
   <p class="pprob3"> 
    Să se genereze toate submulţimile unei mulţimi, ale cărei elemente se introduc de la
    tastatură. Se generează toate submulţimile mulţimii {1,2,...,n} în ordine lexicografică, o
    soluţie reprezentând indici ai elementelor din mulţimea citită.
   </p> </span>
<center> <img src="../images/problema3.jpg" class="prob3"> </center>


 
    
</body>
</html>